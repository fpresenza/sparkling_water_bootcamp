use std::collections::HashSet;
use lambdaworks_math::field::fields::u64_prime_field::U64FieldElement;

const MODULUS: u64 = 17;
// pub type F17 = U64PrimeField<MODULUS>;
type FE = U64FieldElement<MODULUS>;    

fn main() {
    // 
    // basic field operations 
    //
    println!("Basic Field operations on finite field of modulus {}", MODULUS);
    let a = FE::new(10);
    let b = FE::new(7);
    let zero = FE::zero();
    
    // compute a sum
    let add = a + b;
    println!("The sum of 10 and 7 modulo {} is {:?}", MODULUS, add.value());
    
    // compute a product
    let mul = a * b;
    println!("The product of 10 and 7 modulo {} is {:?}", MODULUS, mul.value());
    
    // compute an inverse
    match a.inv() {
        Ok(inv) =>  println!("The inverse of 10 modulo {} is {:?}", MODULUS, inv.value()),
        _ => println!("{} has no inverse modulo 17", a.value())
    };

    // zero has no inverse
    match zero.inv() {
        Ok(inv) =>  println!("The inverse of 10 modulo {} is {:?}", MODULUS, inv.value()),
        _ => println!("{} has no inverse modulo 17", zero.value())
    };


    // 
    // get all multiplicative subgroups of the prime field
    //
    println!("Multiplicative subgroups of finite field of modulus {}", MODULUS);
    for x in 2..MODULUS {
        let base = FE::new(x);
        let mut subgroup: HashSet<u64> = HashSet::new();
        for k in 1..MODULUS {
            subgroup.insert(*base.pow(k).value());
        }
        println!("Multiplicative subgroup generated by {} is: {:?}", x, subgroup);
    };
}
